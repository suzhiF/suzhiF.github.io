[{"title":"Composer 提示 Allowed memory size of bytes exhausted","url":"/2021/04/c8824c4f5063/","content":"运行 composer 命令时提示：\n\nPHP Fatal error:  Allowed memory size of 1610612736 bytes exhausted (tried to allocate 67108864 bytes)\n\n修改 php.ini 中 memory_limit 的值为 -1，重启\n执行 php -r &quot;echo ini_get(&#39;memory_limit&#39;).PHP_EOL;&quot; 查看是否修改成功\n","categories":["错误记录"],"tags":["Composer"]},{"title":"什么是 CSRF","url":"/2021/07/8150c425bab2/","content":"一.CSRF是什么？是什么？是什么？是什么？是什么？是什么？CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。\n二.CSRF可以做什么？你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。\n三.CSRF漏洞现状CSRF这种攻击方式在2000年已经被国外的安全人员提出，但在国内，直到06年才开始被关注，08年，国内外的多个大型社区和交互网站分别爆出CSRF漏洞，如：NYTimes.com（纽约时报）、Metafilter（一个大型的BLOG网站），YouTube和百度HI……而现在，互联网上的许多站点仍对此毫无防备，以至于安全业界称CSRF为“沉睡的巨人”。\n四.CSRF的原理下图简单阐述了CSRF攻击的思想：\n\n从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：\n1.登录受信任网站A，并在本地生成Cookie。\n2.在不登出A的情况下，访问危险网站B。\n看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生：\n1.你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。\n2.你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……）\n3.上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。\n上面大概地讲了一下CSRF攻击的思想，下面我将用几个例子详细说说具体的CSRF攻击，这里我以一个银行转账的操作作为例子（仅仅是例子，真实的银行网站没这么傻:&gt;）\n示例1：\n银行网站A，它以GET请求来完成银行转账的操作，如：http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000\n危险网站B，它里面有一段HTML的代码如下：\nhttp://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000\n\n首先，你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块……\n为什么会这样呢？原因是银行网站A违反了HTTP规范，使用GET请求更新资源。在访问危险网站B的之前，你已经登录了银行网站A，而B中的以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏览器会带上你的银行网站A的Cookie发出Get请求，去获取资源“    http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000”，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作……\n示例2：\n为了杜绝上面的问题，银行决定改用POST请求完成转账操作。\n银行网站A的WEB表单如下：\n　&lt;form action=&quot;Transfer.php&quot; method=&quot;POST&quot;&gt;　　　　&lt;p&gt;ToBankId: &lt;input type=&quot;text&quot; name=&quot;toBankId&quot; /&gt;&lt;/p&gt;　　　　&lt;p&gt;Money: &lt;input type=&quot;text&quot; name=&quot;money&quot; /&gt;&lt;/p&gt;　　　　&lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Transfer&quot; /&gt;&lt;/p&gt;　　&lt;/form&gt;\n\n\n\n后台处理页面Transfer.php如下：\n&lt;?php　　　　session_start();　　　　if (isset($_REQUEST[&#x27;toBankId&#x27;] &amp;&amp;　isset($_REQUEST[&#x27;money&#x27;]))　　　　&#123;　　　　  buy_stocks($_REQUEST[&#x27;toBankId&#x27;],　$_REQUEST[&#x27;money&#x27;]);　　　　&#125;?&gt;\n\n\n\n危险网站B，仍然只是包含那句HTML代码：\n&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;\n\n\n\n和示例1中的操作一样，你首先登录了银行网站A，然后访问危险网站B，结果…..和示例1一样，你再次没了1000块～T_T，这次事故的原因是：银行后台使用了$_REQUEST去获取请求的数据，而$_REQUEST既可以获取GET请求的数据，也可以获取POST请求的数据，这就造成了在后台处理程序无法区分这到底是GET请求的数据还是POST请求的数据。在PHP中，可以使用$_GET和$_POST分别获取GET请求和POST请求的数据。在JAVA中，用于获取请求数据request一样存在不能区分GET请求数据和POST数据的问题。\n示例3：\n经过前面2个惨痛的教训，银行决定把获取请求数据的方法也改了，改用$_POST，只获取POST请求的数据，后台处理页面Transfer.php代码如下：\n&lt;?php　　　　session_start();　　　　if (isset($_POST[&#x27;toBankId&#x27;] &amp;&amp;　isset($_POST[&#x27;money&#x27;]))　　　　&#123;　　　　  buy_stocks($_POST[&#x27;toBankId&#x27;],　$_POST[&#x27;money&#x27;]);　　　　&#125;　　?&gt;\n\n然而，危险网站B与时俱进，它改了一下代码：\n&lt;html&gt;　　&lt;head&gt;　　　　&lt;script type=&quot;text/javascript&quot;&gt;　　　　　　function steal()　　　　　　&#123;          　　　　 iframe = document.frames[&quot;steal&quot;];　　     　　      iframe.document.Submit(&quot;transfer&quot;);　　　　　　&#125;　　　　&lt;/script&gt;　　&lt;/head&gt;　　&lt;body onload=&quot;steal()&quot;&gt;　　　　&lt;iframe name=&quot;steal&quot; display=&quot;none&quot;&gt;　　　　　　&lt;form method=&quot;POST&quot; name=&quot;transfer&quot;　action=&quot;http://www.myBank.com/Transfer.php&quot;&gt;　　　　　　　　&lt;input type=&quot;hidden&quot; name=&quot;toBankId&quot; value=&quot;11&quot;&gt;　　　　　　　　&lt;input type=&quot;hidden&quot; name=&quot;money&quot; value=&quot;1000&quot;&gt;　　　　　　&lt;/form&gt;　　　　&lt;/iframe&gt;　　&lt;/body&gt;&lt;/html&gt;\n\n\n\n如果用户仍是继续上面的操作，很不幸，结果将会是再次不见1000块……因为这里危险网站B暗地里发送了POST请求到银行!\n总结一下上面3个例子，CSRF主要的攻击模式基本上是以上的3种，其中以第1,2种最为严重，因为触发条件很简单，一个就可以了，而第3种比较麻烦，需要使用JavaScript，所以使用的机会会比前面的少很多，但无论是哪种情况，只要触发了CSRF攻击，后果都有可能很严重。\n理解上面的3种攻击模式，其实可以看出，CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！\n五.CSRF的防御我总结了一下看到的资料，CSRF的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的CSRF防御也都在服务端进行。\n1.服务端进行CSRF防御\n服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。\n(1).Cookie Hashing(所有表单都包含同一个伪随机值)：\n这可能是最简单的解决方案了，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了:\n&lt;?php　　　　//构造加密的Cookie信息　　　　$value = “DefenseSCRF”;　　　　setcookie(”cookie”, $value, time()+3600);　　?&gt;\n\n\n\n在表单里增加Hash值，以认证这确实是用户发送的请求。\n　&lt;?php　　　　$hash = md5($_COOKIE[&#x27;cookie&#x27;]);　　?&gt;　　&lt;form method=”POST” action=”transfer.php”&gt;　　　　&lt;input type=”text” name=”toBankId”&gt;　　　　&lt;input type=”text” name=”money”&gt;　　　　&lt;input type=”hidden” name=”hash” value=”&lt;?=$hash;?&gt;”&gt;　　　　&lt;input type=”submit” name=”submit” value=”Submit”&gt;　　&lt;/form&gt;\n\n\n\n然后在服务器端进行Hash值验证\n&lt;?php　　      if(isset($_POST[&#x27;check&#x27;])) &#123;    　　      $hash = md5($_COOKIE[&#x27;cookie&#x27;]);         　　 if($_POST[&#x27;check&#x27;] == $hash) &#123;              　　 doJob();　　           &#125; else &#123;　　　　　　　　//...         　　 &#125;　　      &#125; else &#123;　　　　　　//...　　      &#125;     ?&gt;\n\n\n\n这个方法个人觉得已经可以杜绝99%的CSRF攻击了，那还有1%呢….由于用户的Cookie很容易由于网站的XSS漏洞而被盗取，这就另外的1%。一般的攻击者看到有需要算Hash值，基本都会放弃了，某些除外，所以如果需要100%的杜绝，这个不是最好的方法。(2).验证码\n这个方案的思路是：每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，厄….这个方案可以完全解决CSRF，但个人觉得在易用性方面似乎不是太好，还有听闻是验证码图片的使用涉及了一个被称为MHTML的Bug，可能在某些版本的微软IE中受影响。\n(3).One-Time Tokens(不同的表单包含一个不同的伪随机值)\n在实现One-Time Tokens时，需要注意一点：就是“并行会话的兼容”。如果用户在一个站点上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提交。考虑一下如果每次表单被装入时站点生成一个伪随机值来覆盖以前的伪随机值将会发生什么情况：用户只能成功地提交他最后打开的表单，因为所有其他的表单都含有非法的伪随机值。必须小心操作以确保CSRF保护措施不会影响选项卡式的浏览或者利用多个浏览器窗口浏览一个站点。\n以下我的实现:\n1).先是令牌生成函数(gen_token())：\n&lt;?php     function gen_token() &#123;　　　　//这里我是贪方便，实际上单使用Rand()得出的随机数作为令牌，也是不安全的。　　　　//这个可以参考我写的Findbugs笔记中的《Random object created and used only once》          $token = md5(uniqid(rand(), true));          return $token;     &#125;\n\n\n\n2).然后是Session令牌生成函数(gen_stoken())：\n&lt;?php     　　function gen_stoken() &#123;　　　　　　$pToken = &quot;&quot;;　　　　　　if($_SESSION[STOKEN_NAME]  == $pToken)&#123;　　　　　　　　//没有值，赋新值　　　　　　　　$_SESSION[STOKEN_NAME] = gen_token();　　　　　　&#125;   　　　　　　else&#123;　　　　　　　　//继续使用旧的值　　　　　　&#125;     　　&#125;     ?&gt;\n\n\n\n3).WEB表单生成隐藏输入域的函数：\n&lt;?php　　     function gen_input() &#123;    　　     gen_stoken();　　          echo “&lt;input type=\\”hidden\\” name=\\”&quot; . FTOKEN_NAME . “\\”         　　     value=\\”&quot; . $_SESSION[STOKEN_NAME] . “\\”&gt; “;    　　&#125;    ?&gt;\n\n\n\n4).WEB表单结构：\n&lt;?php         session_start();         include(”functions.php”);    ?&gt;    &lt;form method=”POST” action=”transfer.php”&gt;         &lt;input type=”text” name=”toBankId”&gt;         &lt;input type=”text” name=”money”&gt;         &lt;? gen_input(); ?&gt;         &lt;input type=”submit” name=”submit” value=”Submit”&gt;    &lt;/FORM&gt;\n\n\n\n5).服务端核对令牌\n","categories":["网络"]},{"title":"Docker 常用命令","url":"/2021/07/b934f7bfb536/","content":"\ndocker  [command]  [options]\nattach              # 当前 shell 下 attach 连接指定运行镜像build               # 通过 Dockerfile 定制镜像commit              # 提交当前容器为新的镜像cp                  # 从容器中拷贝指定文件或者目录带宿主机中create              # 创建一个新的容器，同 run ，但不启动容器diff                # 查看 docker 容器变化events              # 从 docker 服务获取容器实时事件exec                # 在已存在的容器上运行命令export              # 导出容器的内容流作为一个 tar 归档文件[对应 import]history             # 展示一个镜像形成的历史images              # 列出系统当前镜像import              # 从 tar 包中的内容创建一个新的文件系统映像[对应 export]info                # 显示系统相关信息inspect             # 查看容器详细信息kill                # kill 指定 docker 容器load                # 从一个 tar 包中加载一个镜像login               # 注册或者登陆一个 docker 源服务器logout              # 从当前 Docker registry 退出logs                # 输出当前容器日志信息port                # 查看映射端口对应容器内部源端口pause               # 暂停容器ps                  # 列出容器列表pull                # 从 docker 镜像源服务器拉取指定镜像或者库镜像push                # 推送指定镜像或者库镜像至 docker 源服务器restart             # 重启运行的容器rm                  # 移除一个或者多个容器rmi                 # 移除一个或者多个镜像[无容器使用该镜像才可删除，否则需删除相关内容才可以继续或 -f 强制删除]run                 # 创建一个新的容器并运行一个命令save                # 保证一个镜像为一个 tar 包[对应 load]search              # 在 docker hub 中搜索镜像start               # 启动容器stop                # 停止容器tag                 # 给源中镜像打标签top                 # 查看容器中运行的进程信息unpause             # 取消暂停容器version             # 查看 docker 版本号wait                # 截取容器停止时的退出状态值\n\n\n参考- 遇见狂神说","tags":["docker"]},{"title":"Laravel 中优化 app.js 的大小","url":"/2021/10/30fc9eddc78b/","content":"\n近期做了一个小项目，前端是通过 Laravel Mix 编译的，产生的 app.js ，大小有 3M 还多，不得不优化一下……\n\n没做任何优化之前：\n\n查看应用的前端库结构\n安装 npm install --save-dev webpack-bundle-analyzer 。\n\n修改 webpack.mix.js 配置 。\nconst BundleAnalyzerPlugin = require(&#x27;webpack-bundle-analyzer&#x27;).BundleAnalyzerPlugin;mix.webpackConfig(&#123; plugins: [     new BundleAnalyzerPlugin(), ]&#125;);\n运行 npm run dev 或者 npm run production ，浏览器中自动打开 http://127.0.0.1:8888/ 页面。\n鼠标悬浮可以显示包大小\n\n\n\n分离内存较大的库这些库会被 webpack 一起打包成一个 app.js，所以减小应用体积的最有效方法就是将这些库分离出去，别将它们与我们自己写的应用代码打包到一起。大部分有名的第三方库在公共CDN都有存放，如 bootcss, unpkg 等，速度飞快，可以直接引用。\n\n配置 webpack.mix.js ：\nmix.webpackConfig(&#123;    plugins: [        new BundleAnalyzerPlugin(),    ],    externals: &#123;        &#x27;element-ui&#x27;: &#x27;Element&#x27;,        &#x27;vue&#x27;: &#x27;Vue&#x27;,        &#x27;lodash&#x27;: &#x27;_&#x27;,    &#125;&#125;).js(&#x27;resources/js/app.js&#x27;, &#x27;public/js&#x27;)    .sass(&#x27;resources/sass/app.scss&#x27;, &#x27;public/css&#x27;);\nresources/views/layouts/app.blade.php 文件中加入 element-ui、vue、lodash 的外链\n&lt;link href=&quot;https://cdn.bootcss.com/element-ui/2.0.11/theme-chalk/index.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;script src=&quot;//cdn.bootcss.com/vue/2.5.13/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;//cdn.bootcss.com/element-ui/2.0.11/index.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;//cdn.bootcss.com/lodash.js/4.17.4/lodash.min.js&quot;&gt;&lt;/script&gt;\n resources/js/app.js 和 resources/js/bootstrap.js 文件中将 require(&#39;vue&#39;) 、require(&#39;lodash&#39;) 、import ElementUI from &#39;element-ui&#39; 的位置删除，否则编译时会报错。\n\n运行 npm run dev\n\n运行 npm run production\n\n\n优化浏览器加载时的大小在这里要做的就是开启 Nginx 的 gzip 压缩 。\n\n没开启时：\n开启 gzip 压缩后\n\nnginx.conf 中配置：\n#gzip  on;gzip on;gzip_min_length  1k;            # 不压缩临界值，大于1K的才压缩，一般不用改gzip_buffers     4 32k;         # 设置用于处理请求压缩的缓冲区数量和大小。比如32 4K表示按照内存页（one memory page）大小以4K为单位（即一个系统中内存页为4K），申请32倍的内存空间。建议此项不设置，使用默认值。gzip_http_version 1.1;          gzip_comp_level 2;              # 压缩级别，1-10，数字越大压缩的越好，时间也越长，看心情随便改吧gzip_types       text/plain application/x-javascript text/css application/xml;      # 进行压缩的文件类型gzip_vary on;          # 跟Squid等缓存服务有关，on的话会在Header里增加&quot;Vary: Accept-Encoding&quot;，按需开启gzip_disable &quot;MSIE [1-6].&quot;;\n\n\n\n参考- Laravel框架中缩小Vue应用的体积\n\n\n\n\n\n","categories":["Laravel"],"tags":["Laravel","Laravel-Mix","webpack"]},{"title":"Linux 内存进程命令","url":"/2021/07/d8af1e4291bf/","content":"top常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况\nvagrant@homestead:~$ top -help  procps-ng 3.3.12Usage:  top -hv | -bcHiOSs -d secs -n max -u|U user -p pid(s) -o field -w [cols]  vagrant@homestead:~$ top\n\n\nPID：    进程的IDUSER：   进程所有者PR：     进程的优先级别，越小越优先被执行NInice： 值VIRT：   进程占用的虚拟内存RES：    进程占用的物理内存SHR：    进程使用的共享内存S：      进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数%CPU：   进程占用CPU的使用率%MEM：   进程使用的物理内存和总内存的百分比TIME+：  该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。COMMAND：进程启动命令名称\n\n","categories":["Linux"],"tags":["linux","top","linux进程"]},{"title":"MongoDB 地理空间","url":"/2021/08/8c38ef739811/","content":"GeoJSON 对象&lt;field&gt;: &#123;     type: &lt;GeoJSON type&gt; ,      # 指定的 GeoJSON 类型 (Point、LineString、Polygon……)    coordinates: &lt;coordinates&gt;  # 指定对象坐标的字段 [&lt;longitude&gt;, &lt;latitude&gt; ]&#125;   # 例：location: &#123;    type: &quot;Point&quot;,    coordinates: [ 116.408, 39.904]&#125;\n\n传统坐标对# 数组型&lt;field&gt;: [ &lt;x&gt;, &lt;y&gt; ] # 或&lt;field&gt;: [&lt;longitude&gt;, &lt;latitude&gt; ]# 或 嵌入文档型&lt;field&gt;: &#123; &lt;field1&gt;: &lt;longitude&gt;, &lt;field2&gt;: &lt;latitude&gt; &#125;# 要指定旧坐标对，数组优先于嵌入文档，因为某些语言不保证关联地图排序\n\n地理空间索引\n2dsphere\n\n2dsphere 索引支持在类地球体上计算几何图形的查询\n# 创建 2dsphere 索引：db.collection.createIndex( &#123; &lt;location field&gt; : &quot;2dsphere&quot; &#125; )\n\n其中 &lt;location field&gt; 是一个字段，其值为 GeoJSON 对象或传统坐标对\n\n2d\n\n2d索引支持在二维平面上计算几何的查询, 可以支持 $nearSphere 在球面上计算的查询。（适用于 MongoDB 2.2 及更早版本）\ndb.collection.createIndex( &#123; &lt;location field&gt; : &quot;2d&quot; &#125; )\n\n其中 &lt;location field&gt; 是一个字段，其值为传统坐标对。\n地理空间查询运算符\n\n\n名称\n描述\n\n\n\n$geoIntersects\n选择与 GeoJSON 几何相交的几何。 2dsphere 索引支持 $geoIntersects。\n\n\n$geoWithin\n在边界GeoJSON 几何中选择几何。 2dsphere 和 2d 指标支持 $geoWithin。\n\n\n$near\n返回点附近的地理空间对象。需要地理空间索引。 2dsphere 和 2d 指标支持 $near。\n\n\n$nearSphere\n返回球体上某个点附近的地理空间对象。需要地理空间索引。 2dsphere 和 2d 指标支持 $nearSphere。\n\n\n地理空间聚合阶段\n$geoNear\n\n按离指定点最近到最远的顺序输出文档。\n&#123; $geoNear: &#123;   &lt;geoNear options&gt;   &#125; &#125;\n\n\n\n\n字段\n类型\n描述\n\n\n\ndistanceField\nstring\n包含计算距离的输出字段\n\n\ndistanceMultiplier\nnumber\n可选的。乘以查询返回的所有距离的因子。例如，使用 distanceMultiplier 将球面查询返回的弧度乘以地球的半径来转换为公里\n\n\nincludeLocs\nstring\n可选的。这指定了标识用于计算距离的位置的输出字段。当位置字段包含多个位置时，此选项很有用\n\n\nkey\n\n可选的。指定计算距离时要使用的地理空间索引字段。如果您的集合具有多个2d和/或多个2dsphere 索引，则必须使用该key选项来指定要使用的索引字段路径\n\n\nmaxDistance\nnumber\n可选的。到中心点的最大距离\n\n\nminDistance\nnumber\n可选的。到中心点的最小距离\n\n\nnear\nGeoJSON 或 传统坐标对\n查找最近文档的点\n\n\nquery\ndocument\n查询的匹配条件\n\n\nspherical\nboolean\n可选的。确定 MongoDB 如何计算两点之间的距离。true：MongoDB 使用 $nearSphere 语义并使用球面几何计算距离**\n\n\nfalse**：MongoDB 使用 $near 语义：2dsphere 索引的球面几何和 2d 索引的平面几何\n\n\n\n\nuniqueDocs\nboolean\n可选的。如果此值为true，则查询会返回匹配的文档一次，即使文档的多个位置字段与查询匹配也是如此（2.6版后已弃用）\n\n\n\n只能使用$geoNear作为管道的第一阶段。\n必须包含 distanceField 字段。\n$geoNear 需要地理空间索引，如果集合中有多个地理空间索引，请使用 keys参数指定要在计算中使用的字段。如果您只有一个地理空间索引，则$geoNear隐式使用索引字段进行计算。\n不能在 $geoNear 阶段的查询字段中指定 $near 谓词\n视图不支持 geoNear 操作\n从 4.2 版开始，$geoNear 不再有 100 个文档的默认限制\n\n\n示例 1：\n\n查找距离 [ -73.99279 , 40.719296 ] 点最小距离 2m ,并且 category 是 Parks 的所有文档\ndb.citys.aggregate([    &#123;        $geoNear: &#123;            near: &#123;                type: &quot;Point&quot;,                coordinates: [116.408, 39.904]            &#125;,            distanceMultiplier: 1/1000,           # 计算出的距离按公里显示            distanceField: &quot;dist.calculated&quot;,            includeLocs: &quot;dist.location&quot;,            minDistance: 2,            spherical: true        &#125;    &#125;])##### 结果 #####// 1&#123;    &quot;_id&quot;: ObjectId(&quot;610b931fd2620000ac000144&quot;),    &quot;name&quot;: &quot;tianjin&quot;,    &quot;location&quot;: &#123;        &quot;type&quot;: &quot;Point&quot;,        &quot;coordinates&quot;: [            117.246,            39.117        ]    &#125;,    &quot;dist&quot;: &#123;        &quot;calculated&quot;: 113.378060984206,       # 计算距离的字段        &quot;location&quot;: &#123;                         # 计算中使用的位置的字段            &quot;type&quot;: &quot;Point&quot;,            &quot;coordinates&quot;: [                117.246,                39.117            ]        &#125;    &#125;&#125;\n\n\n示例2：一个集合有多个地理空间索引\n\nplaces 集合中 location 字段有一个 2dsphere 索引， legacy字段有一个 2d 索引 如下：\n&#123;   &quot;_id&quot; : 3,   &quot;name&quot; : &quot;Polo Grounds&quot;,   &quot;location&quot;: &#123;      &quot;type&quot; : &quot;Point&quot;,      &quot;coordinates&quot; : [ -73.9375, 40.8303 ]   &#125;,   &quot;legacy&quot; : [ -73.9375, 40.8303 ],   &quot;category&quot; : &quot;Stadiums&quot;&#125;\n\n使用 key 选项来指定聚集应该使用 location 的字段值的 $geoNear 操作，而不是 legacy 字段值\ndb.places.aggregate([   &#123;     $geoNear: &#123;        near: &#123; type: &quot;Point&quot;, coordinates: [ -73.98142 , 40.71782 ] &#125;,        key: &quot;location&quot;,        distanceField: &quot;dist.calculated&quot;,        query: &#123; &quot;category&quot;: &quot;Parks&quot; &#125;     &#125;   &#125;,   &#123; $limit: 5 &#125;])##### 结果 #####&#123;   &quot;_id&quot; : 8,   &quot;name&quot; : &quot;Sara D. Roosevelt Park&quot;,   &quot;location&quot; : &#123;      &quot;type&quot; : &quot;Point&quot;,      &quot;coordinates&quot; : [         -73.9928,         40.7193      ]   &#125;,   &quot;category&quot; : &quot;Parks&quot;,   &quot;dist&quot; : &#123;      &quot;calculated&quot; : 974.175764916902   &#125;&#125;&#123;   &quot;_id&quot; : 1,   &quot;name&quot; : &quot;Central Park&quot;,   &quot;location&quot; : &#123;      &quot;type&quot; : &quot;Point&quot;,      &quot;coordinates&quot; : [         -73.97,         40.77      ]   &#125;,   &quot;legacy&quot; : [      -73.97,      40.77   ],   &quot;category&quot; : &quot;Parks&quot;,   &quot;dist&quot; : &#123;      &quot;calculated&quot; : 5887.92792958097   &#125;&#125;\n\n案例# 创建集合db.provinces.insertMany([  &#123; name: &quot;北京&quot;, location: &#123; type: &quot;Point&quot;, coordinates: [116.41667, 39.91667] &#125; &#125;,  &#123; name: &quot;山东&quot;, location: &#123; type: &quot;Point&quot;, coordinates: [117.000923, 36.675807] &#125;&#125;,  &#123; name: &quot;河北&quot;, location: &#123; type: &quot;Point&quot;, coordinates: [115.48333, 38.03333] &#125; &#125;,  &#123; name: &quot;吉林&quot;, location: &#123; type: &quot;Point&quot;, coordinates: [127.63333, 47.75000] &#125; &#125;,  &#123; name: &quot;辽宁&quot;, location: &#123; type: &quot;Point&quot;, coordinates: [123.38333, 41.80000] &#125; &#125;,  &#123; name: &quot;新疆&quot;, location: &#123; type: &quot;Point&quot;, coordinates: [87.68333, 43.76667] &#125; &#125;,  &#123; name: &quot;广东&quot;, location: &#123; type: &quot;Point&quot;, coordinates: [113.23333, 23.16667] &#125; &#125;,  &#123; name: &quot;江西&quot;, location: &#123; type: &quot;Point&quot;, coordinates: [115.90000, 28.68333] &#125; &#125;,  &#123; name: &quot;海南&quot;, location: &#123; type: &quot;Point&quot;, coordinates: [110.35000, 20.01667] &#125; &#125;,  &#123; name: &quot;上海&quot;, location: &#123; type: &quot;Point&quot;, coordinates: [121.55333, 31.20000] &#125; &#125;,  &#123; name: &quot;重庆&quot;, location: &#123; type: &quot;Point&quot;, coordinates: [106.45000, 29.56667] &#125; &#125;,  &#123; name: &quot;天津&quot;, location: &#123; type: &quot;Point&quot;, coordinates: [117.20000, 39.13333] &#125; &#125;,])# 创建地理空间索引db.provinces.createIndex(&#123;location: &quot;2dsphere&quot;&#125;)# [120.39629, 36.30744]db.provinces.findOne(&#123;  geometry: &#123;    $geoIntersects: &#123;      $geometry: &#123; type: &quot;Point&quot;, coordinates: [117.000923, 36.675807] &#125;    &#125;  &#125;&#125;)\n","categories":["MongoDB"],"tags":["MongoDB"]},{"title":"MongoDB 运算符","url":"/2021/08/b4b49ce1fe51/","content":"查询\n比较\n\n\n\n\n名称\n描述\n\n\n\n$eq\n匹配 等于 指定值的值\n\n\n$gt\n匹配 大于 指定值的值\n\n\n$gte\n匹配 大于或等于 指定值的值\n\n\n$in\n匹配 数组中 指定的任何值\n\n\n$lt\n匹配 小于 指定值的值\n\n\n$lte\n匹配 小于或等于 指定值的值\n\n\n$ne\n匹配 所有不等于 指定值的值\n\n\n$nin\n不匹配数组中指定的任何值\n\n\n\n逻辑\n\n\n\n\n名称\n描述\n\n\n\n$and\n将查询子句与逻辑 AND 连接，返回匹配这两个子句条件的所有文档\n\n\n$not\n反转查询表达式的效果，并返回与查询表达式不匹配的文档\n\n\n$nor\n将查询子句与逻辑 NOR 连接，返回两个子句都不匹配的所有文档。\n\n\n$or\n将查询子句与逻辑 OR 连接，返回与任一子句条件匹配的所有文档\n\n\n\n元素\n\n\n\n\n名称\n描述\n\n\n\n$exists\n匹配具有指定字段的文档\n\n\n$type\n如果字段为指定类型，则选择文档\n\n\n更新\n字段\n\n\n\n\n名称\n描述\n\n\n\n$currentDate\n将字段的值设置为当前日期，作为日期或时间戳\n\n\n$inc\n将字段的值增加指定的数量\n\n\n$min\n仅当指定值小于现有字段值时才更新该字段\n\n\n$max\n仅当指定值大于现有字段值时才更新该字段\n\n\n$mul\n将字段的值乘以指定的数量\n\n\n$rename\n重命名字段\n\n\n$set\n设置文档中字段的值\n\n\n$setOnInsert\n如果更新导致插入文档，则设置字段的值。对修改现有文档的更新操作没有影响\n\n\n$unset\n从文档中删除指定的字段\n\n\ntest&gt; db.inventory.updateOne(... &#123;item:&quot;paper&quot;&#125;,... &#123;..... $set: &#123;&quot;size.uom&quot;:&quot;cm&quot;, status:&quot;p&quot;&#125;,..... $currentDate: &#123;lastModified: true&#125;..... &#125;... )&#123;  acknowledged: true,  insertedId: null,  matchedCount: 1,  modifiedCount: 1,  upsertedCount: 0&#125;\n\n\n数组\n\n\n\n\n名称\n描述\n\n\n\n$\n充当占位符以更新与查询条件匹配的第一个元素\n\n\n$[]\n充当占位符，为匹配查询条件的文档更新数组中的所有元素\n\n\n$[&lt;identifier&gt;]\n充当占位符，arrayFilters为符合查询条件的文档更新符合条件的所有元素\n\n\n$addToSet\n仅当集合中尚不存在元素时，才将元素添加到数组中\n\n\n$pop\n删除数组的第一项或最后一项\n\n\n$pull\n删除与指定查询匹配的所有数组元素\n\n\n$push\n将项目添加到数组\n\n\n$pullAll\n从数组中删除所有匹配的值\n\n\n","categories":["MongoDB"],"tags":["MongoDB"]},{"title":"MySQL 索引失效情况","url":"/2021/08/41e3cb957215/","content":"User 表：\n\n\n1：查询的数量是大表的大部分，30％以上，索引失效\n\n\n2：like 以 % 开头，索引失效\n\n################ 创建 name 字段的索引 ################mysql&gt; CREATE INDEX name ON users(name);Query OK, 0 rows affected (0.00 sec)Records: 0  Duplicates: 0  Warnings: 0################ 以 % 开头，索引失效 ################mysql&gt; explain select * from users where name like &quot;%四&quot;;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+|  1 | SIMPLE      | users | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    5 |    20.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+1 row in set, 1 warning (0.00 sec)################ 以 % 结尾，索引生效 ################mysql&gt; explain select * from users where name like &quot;四%&quot;;+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra                 |+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+|  1 | SIMPLE      | users | NULL       | range | name          | name | 1022    | NULL |    1 |   100.00 | Using index condition |+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+1 row in set, 1 warning (0.00 sec)\n\n\n3：or 只要其中一个条件没有索引，索引失效\n\n################ 当前 email 字段没有索引 ################mysql&gt; explain select * from users where email = &quot;1234@tt.com&quot; or name = &quot;赵四&quot;;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+|  1 | SIMPLE      | users | NULL       | ALL  | name          | NULL | NULL    | NULL |    5 |    36.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+1 row in set, 1 warning (0.00 sec)  ################ 添加 email 索引 ################mysql&gt; create index email on users(email);Query OK, 0 rows affected (0.02 sec)Records: 0  Duplicates: 0  Warnings: 0################ 索引生效！ ################mysql&gt; mysql&gt; explain select * from users where email = &quot;1234@tt.com&quot; or name = &quot;赵四&quot;;+----+-------------+-------+------------+-------------+---------------+------------+-----------+------+------+----------+--------------------------------------+| id | select_type | table | partitions | type        | possible_keys | key        | key_len   | ref  | rows | filtered | Extra                                |+----+-------------+-------+------------+-------------+---------------+------------+-----------+------+------+----------+--------------------------------------+|  1 | SIMPLE      | users | NULL       | index_merge | name,email    | email,name | 1023,1023 | NULL |    2 |   100.00 | Using union(email,name); Using where |+----+-------------+-------+------------+-------------+---------------+------------+-----------+------+------+----------+--------------------------------------+1 row in set, 1 warning (0.00 sec)\n\n\n4：对于多列索引，不是使用的第一部分(第一个)，索引失效\n\nmysql&gt; drop index name on users;Query OK, 0 rows affected (0.00 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; drop index email on users;Query OK, 0 rows affected (0.00 sec)Records: 0  Duplicates: 0  Warnings: 0################ 创建组合索引 ################mysql&gt; create index name_email_age on users(name, email,age);Query OK, 0 rows affected (0.01 sec)Records: 0  Duplicates: 0  Warnings: 0################ 索引生效！ ################mysql&gt; explain select * from users where name = &#x27;赵四&#x27;and age = 51;+----+-------------+-------+------------+------+----------------+----------------+---------+-------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys  | key            | key_len | ref   | rows | filtered | Extra                 |+----+-------------+-------+------------+------+----------------+----------------+---------+-------+------+----------+-----------------------+|  1 | SIMPLE      | users | NULL       | ref  | name_email_age | name_email_age | 1023    | const |    1 |    10.00 | Using index condition |+----+-------------+-------+------------+------+----------------+----------------+---------+-------+------+----------+-----------------------+1 row in set, 1 warning (0.00 sec)################ 索引失效！ ################mysql&gt; explain select * from users where email = &#x27;1232@tt.com&#x27; and age = 51;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+|  1 | SIMPLE      | users | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   14 |     7.14 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+1 row in set, 1 warning (0.00 sec)\n\n\n5：数据类型出现隐式转化。如varchar不加单引号的话可能会自动转换为int型，索引失效\n\nmysql&gt; explain select * from users where name = 111;+----+-------------+-------+------------+------+----------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys  | key  | key_len | ref  | rows | filtered | Extra       |+----+-------------+-------+------------+------+----------------+------+---------+------+------+----------+-------------+|  1 | SIMPLE      | users | NULL       | ALL  | name_email_age | NULL | NULL    | NULL |   14 |    10.00 | Using where |+----+-------------+-------+------------+------+----------------+------+---------+------+------+----------+-------------+1 row in set, 3 warnings (0.00 sec)mysql&gt; explain select * from users where name = &quot;111&quot;;+----+-------------+-------+------------+------+----------------+----------------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys  | key            | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+------+----------------+----------------+---------+-------+------+----------+-------+|  1 | SIMPLE      | users | NULL       | ref  | name_email_age | name_email_age | 1023    | const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+------+----------------+----------------+---------+-------+------+----------+-------+1 row in set, 1 warning (0.00 sec)\n\n\n6：当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效\n\n\n7：索引列进行运算.需要建立函数索引\n\n","categories":["MySQL"],"tags":["mysql索引"]},{"title":"Sql 语句编写规范","url":"/2021/01/cbc8329bad3b/","content":"1.使用 limit 对查询结果的记录进行限定2. 避免 select * ，将需要查找的字段列出来3. 使用连接（join）来代替子查询4. 拆分大的 delete 或 insert 语句5. 可通过开启慢查询日志来找出较慢的 SQL6. 不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边7.sql 语句尽可能简单：一条 sql 只能在一个 cpu 运算；大语句拆小语句，减少锁时间；一条大 sql 可以堵死整个库9. 不用函数和触发器，在应用程序实现10. 避免 % xxx 式查询12. 使用同类型进行比较，比如用’123’和’123’比，123 和 123 比15. 列表数据不要拿全表，要使用 LIMIT 来分页，. 每页数量也不要太大\n"},{"title":"PHP 中 Redis 常用操作（set 类型）","url":"/2021/07/ac3227b76e78/","content":"Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的接口，这是也是list所不能提供了。\nRedis的Set是string类型的无需集合。它底层其实是一个value为null的hash表，所以添加、删除、查找的复杂度都是O(1)。\n集合数据的特征：\n\n元素不能重复，保持唯一性\n元素无序，不能使用索引(下标)操作\n\n添加元素到集合(sAdd)\n$redis-&gt;sAdd(&#x27;k&#x27;, &#x27;v1&#x27;);                // int(1)$redis-&gt;sAdd(&#x27;k&#x27;, &#x27;v1&#x27;, &#x27;v2&#x27;, &#x27;v3&#x27;);    // int(2)\n\n随机获取一个元素或多个(sPop)\n无序性，是随机的\n$redis-&gt;sAdd(&#x27;k&#x27;, &#x27;v1&#x27;, &#x27;v2&#x27;, &#x27;v3&#x27;, &#x27;v4&#x27;);$redis-&gt;sPop(&#x27;k&#x27;);            // &#x27;v1&#x27;,$redis-&gt;sPop(&#x27;k&#x27;);            // &#x27;v3&#x27;,$redis-&gt;sPop(&#x27;k&#x27;, 2);            // [&#x27;v1&#x27;,&#x27;v3&#x27;],\n\n删除集合里指定的值(sRem)\n$redis-&gt;sAdd(&#x27;k&#x27;, &#x27;v1&#x27;, &#x27;v2&#x27;, &#x27;v3&#x27;);$redis-&gt;sRem(&#x27;k&#x27;, &#x27;v2&#x27;, &#x27;v3&#x27;);      // k =&gt; array(&#x27;v1&#x27;)\n\n遍历集合(sScan)\n//不使用迭代器，匹配所有的元素，进行遍历$iterator = null;$elements = $redis-&gt;sScan(&#x27;team&#x27;, $iterator, &#x27;*&#x27;);foreach ($elements as $element) &#123;    echo $element, &#x27;&lt;br&gt;&#x27;;&#125;\n\n获取所有成员(sMembers)\n$redis-&gt;sAdd(&#x27;k&#x27;, &#x27;v1&#x27;, &#x27;v2&#x27;, &#x27;v3&#x27;);$members = $redis-&gt;sMembers(&#x27;k&#x27;);var_dump($members);\n\n获取集合元素个数(sCard)\n$redis-&gt;sAdd(&#x27;k&#x27;, &#x27;v1&#x27;, &#x27;v2&#x27;, &#x27;v3&#x27;);$redis-&gt;sCard(&#x27;k&#x27;);    // 3\n\n并集(sUnion)，差集(sDiff),交集(sInter)\n$redis-&gt;sAdd(&#x27;s0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;);$redis-&gt;sAdd(&#x27;s1&#x27;, &#x27;3&#x27;, &#x27;1&#x27;);$redis-&gt;sAdd(&#x27;s2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;);var_dump($redis-&gt;sUnion(&#x27;s0&#x27;, &#x27;s1&#x27;, &#x27;s2&#x27;));//array(4) &#123;//  [0]=&gt;//  string(1) &quot;3&quot;//  [1]=&gt;//  string(1) &quot;4&quot;//  [2]=&gt;//  string(1) &quot;1&quot;//  [3]=&gt;//  string(1) &quot;2&quot;//&#125;var_dump($redis-&gt;sDiff(&#x27;s1&#x27;, &#x27;s2&#x27;));//array(2) &#123;//  [0]=&gt;//  string(1) &quot;1&quot;//  [0]=&gt;//  string(1) &quot;4&quot;// &#125;var_dump($redis-&gt;sDiff(&#x27;s1&#x27;, &#x27;s2&#x27;));//array(1) &#123;//  [0]=&gt;//  string(1) &quot;3&quot;// &#125;\n\n","categories":["Redis"],"tags":["php","redis"]},{"title":"PHP 中 Redis 常用操作（list 类型）","url":"/2021/07/bd70d53460ec/","content":"Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）\n一个列表最多可以包含232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。\n将元素压入链表(lPush)\nlPush() 方法将数据从左侧压入列表\nrPush() 方法将数据从右侧压入列表\n$redis-&gt;lPush(&#x27;list1&#x27;, &#x27;v1&#x27;, &#x27;v2&#x27;, &#x27;v3&#x27;, &#x27;v4&#x27;)$redis-&gt;lPush(&#x27;list2&#x27;, &#x27;v1&#x27;, &#x27;v2&#x27;, &#x27;v3&#x27;, &#x27;v4&#x27;)var_dump( $redis-&gt;lRange(&#x27;list1&#x27;, 0, -1) );var_dump( $redis-&gt;lRange(&#x27;list2&#x27;, 0, -1) );// list1:// array(4) &#123;//   [0]=&gt; string(2) &quot;v4&quot;//   [1]=&gt; string(2) &quot;v3&quot;//   [2]=&gt; string(2) &quot;v2&quot;//   [3]=&gt; string(2) &quot;v1&quot;// &#125;// list2:// array(4) &#123;//   [0]=&gt; string(2) &quot;v1&quot;//   [1]=&gt; string(2) &quot;v2&quot;//   [2]=&gt; string(2) &quot;v3&quot;//   [3]=&gt; string(2) &quot;v4&quot;// &#125;\n\n在某个位置插入新元素(lInsert)\nRedis::BEFORE 在之前插入\nRedis::AFTER 在之后插入\n$redis-&gt;lPush(&#x27;list1&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;v4&#x27;)$redis-&gt;lInsert(&#x27;list&#x27;, Redis::BEFORE, &#x27;C&#x27;, &#x27;X&#x27;);$redis-&gt;lInsert(&#x27;list&#x27;, Redis::AFTER, &#x27;C&#x27;, &#x27;Y&#x27;);$redis-&gt;lRange(&#x27;list&#x27;, 0, -1);// array(&#x27;A&#x27;, &#x27;B&#x27;, &#x27;X&#x27;, &#x27;C&#x27;，&#x27;Y&#x27;)\n\n设置、获取某个元素的值(lSet、lGet)\nlSet() 方法可以通过下标修改链表元素的值，下标是从0开始lGet() 方法可以通过下标获取链表元素的值，下标是从0开始\n$redis-&gt;lPush(&#x27;list1&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;)$redis-&gt;lGet(&#x27;key1&#x27;, 0);     // &#x27;A&#x27;$redis-&gt;lSet(&#x27;key1&#x27;, 0, &#x27;X&#x27;);$redis-&gt;lGet(&#x27;key1&#x27;, 0);     // &#x27;X&#x27;\n\n获取列表元素个数(lLen)\n$length = $redis-&gt;lLen(&#x27;list&#x27;);echo $length;\n\n获取下标对应的元素(lIndex)\n$val = $redis-&gt;lIndex(&#x27;list&#x27;, 1);echo $val;\n\n获取某个选定范围元素集(lRange)\n通过起止下标来获取列表某个范围内的元素集\n$arr = $redis-&gt;lRange(&#x27;list&#x27;, 0, 1); //前两个元素$arr = $redis-&gt;lRange(&#x27;list&#x27;, 0, -1); //全部元素$arr = $redis-&gt;lRange(&#x27;list&#x27;, -2, -1); //后两个元素var_dump($arr);\n\n从列表左侧弹出数据(lPop)\nlPop() 方法将数据从列表左侧弹出，返回弹出的元素，数据元素在list中消失。\nrPop() 右侧弹出\n$redis-&gt;lPush(&#x27;list&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;)$val = $redis-&gt;lPop(&#x27;list&#x27;);    // list =&gt; [ &#x27;B&#x27;, &#x27;C&#x27; ]$val = $redis-&gt;rPop(&#x27;list&#x27;);    // list =&gt; [ &#x27;B&#x27; ]\n\n根据值移除元素(lRem)\n根据值来移除元素，并且可以指定要移除的元素个数，因为 list 中可能出现重复的元素\n$redis-&gt;lPush(&#x27;list&#x27;, &#x27;A&#x27;, &#x27;A&#x27;, &#x27;C&#x27;, &#x27;B&#x27;, &#x27;A&#x27;)$redis-&gt;lRange(&#x27;key1&#x27;, 0, -1);   // array(&#x27;A&#x27;, &#x27;A&#x27;, &#x27;C&#x27;, &#x27;B&#x27;, &#x27;A&#x27;)$redis-&gt;lRem(&#x27;key1&#x27;, &#x27;A&#x27;, 2);$redis-&gt;lRange(&#x27;key1&#x27;, 0, -1);   // array(&#x27;C&#x27;, &#x27;B&#x27;, &#x27;A&#x27;)\n\n","categories":["Redis"],"tags":["php","redis"]},{"title":"PHP 中 Redis 常用操作（string 类型）","url":"/2021/07/634c5e00d421/","content":"\nstring 是 Redis 最基本的类型，和 Memcached 一模一样的类型，一个key对应一个value。\n string 类型是二进制安全的。这意味着 Redis 的 string 可以包含任何数据。比如JPG图片或者序列化的对象。\n 一个 Redis 中字符串 value 最多可以是512M\n\n设置(set)\n仅支持字符串操作，不支持内置数据编码功能。如果需要存储PHP的非字符串类型，需要提前手动序列化，获取时再反序列化。\n$user = [    &#x27;name&#x27; =&gt; &#x27;zhaosi&#x27;,    &#x27;age&#x27;  =&gt; 49,];//将$user数组序列化成json字符串$user = json_encode($user);$redis-&gt;set(&#x27;user&#x27;, $user);$data = $redis-&gt;get(&#x27;user&#x27;);//拿到序列化后的字符串，再反序列化成PHP数组$data = json_decode($data, true);var_dump($data);\nsetnx() 方法是只有在 key 不存在时设置 key 的值，\n设置并指定过期时间(setex)\n设置键的同时，设置过期时间(秒)\n$redis-&gt;setex(&#x27;user&#x27;, 60, &#x27;user_1256465&#x27;);\n\n获取值(get)\n$redis-&gt;set(&#x27;name&#x27;, &#x27;liuneng&#x27;); //设置$name = $redis-&gt;get(&#x27;name&#x27;);    //获取var_dump($name);\n\n增加(incr, incrBy)\nincr()、incrBy() 都是操作数字，对数字进行增加的操作，incr是执行原子加1操作，incrBy是增加指定的数\n$redis-&gt;set(&#x27;age&#x27;, 49);$redis-&gt;incr(&#x27;age&#x27;); //等于$age++$redis-&gt;incrBy(&#x27;age&#x27;, 10); // 等于$age = $age + 10\n\n减少(decr, decrBy)\ndecr() 和 decrBy() 方法是对数字进行减的操作，和 incr 正好相反\n$redis-&gt;set(&#x27;age&#x27;, 20);$redis-&gt;decr(&#x27;age&#x27;); //等于$age--$redis-&gt;decrBy(&#x27;age&#x27;, 10); // 等于$age = $age - 5\n\n追加(append)\nappend() 表示往字符串后面追加元素，返回值是字符串的总长度\n示例：在’hello’后面追加’ world’\n$redis-&gt;set(&#x27;welcome&#x27;, &#x27;hello&#x27;);$length = $redis-&gt;append(&#x27;welcome&#x27;, &#x27; world&#x27;);var_dump($length);\n\n获取长度(strLen)\nstrLen() 方法可以获取字符串的长度\n$redis-&gt;set(&#x27;name&#x27;, &#x27;zhaosi&#x27;);$length = $redis-&gt;strlen(&#x27;name&#x27;);var_dump($length);  // 6\n\n字符串截取(getRange)\ngetRange() 方法可以用来截取字符串的部分内容,第二个参数是下标索引的开始位置，第三个参数是下标索引的结束位置(不是要截取的长度)，\n$redis-&gt;set(&#x27;ID&#x27;, &#x27;411521199809151234&#x27;);$subStr = $redis-&gt;getRange(&#x27;ID&#x27;, 0, 5);var_dump($subStr);\n\n返回所有指定键的值mget()\n$redis-&gt;set(&#x27;user_1&#x27;,&#x27;zhaosan&#x27;);$redis-&gt;set(&#x27;user_2&#x27;,&#x27;zhaosi&#x27;);$data = $redis-&gt;mget([&#x27;user_1&#x27;,&#x27;user_2&#x27;]);var_dump($data);\n\n设置多个 key-value mset()\n$redis-&gt;mset(array(&#x27;key0&#x27; =&gt; &#x27;value0&#x27;, &#x27;key1&#x27; =&gt; &#x27;value1&#x27;));var_dump($redis-&gt;get(&#x27;key0&#x27;));var_dump($redis-&gt;get(&#x27;key1&#x27;));\n设置一个值并返回该键处的前一个条目\n$redis-&gt;set(&#x27;x&#x27;, &#x27;42&#x27;);$exValue = $redis-&gt;getSet(&#x27;x&#x27;, &#x27;lol&#x27;);   // return &#x27;42&#x27;, replaces x by &#x27;lol&#x27;$newValue = $redis-&gt;get(&#x27;x&#x27;)&#x27;            // return &#x27;lol&#x27;\n…..\n","categories":["Redis"],"tags":["php","redis"]},{"title":"PHP 中 Redis 常用操作（zset 类型）","url":"/2021/07/c6af5ed70b30/","content":"Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。\n不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。\n有序集合的成员是唯一的,但分数(score)却可以重复。处理元素时，也要加上score的处理\n集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。\n添加元素(zAdd)\n$redis-&gt;zAdd(&#x27;zSet&#x27;, 10, &#x27;A&#x27;);$redis-&gt;zAdd(&#x27;zSet&#x27;, 106, &#x27;B&#x27;);$redis-&gt;zAdd(&#x27;zSet&#x27;, 20, &#x27;C&#x27;);$redis-&gt;zAdd(&#x27;zSet&#x27;, 15, &#x27;D&#x27;);$redis-&gt;zAdd(&#x27;zSet&#x27;, 11, &#x27;E&#x27;);\n\n元素分值增减(zIncrBy)\n$redis-&gt;zIncrBy(&#x27;zSet&#x27;, 20.5, &#x27;A&#x27;);      // 30.5$redis-&gt;zIncrBy(&#x27;zSet&#x27;, 12, &#x27;B&#x27;);       // 128\n\n获取根据 score 排序后的数据段(zRange,zRevRange)\n// 升序$redis-&gt;zRange(&#x27;zSet&#x27;, 0, -1)//array (size=5)//  0 =&gt; string &#x27;E&#x27; (length=1)//  1 =&gt; string &#x27;D&#x27; (length=1)//  2 =&gt; string &#x27;C&#x27; (length=1)//  3 =&gt; string &#x27;A&#x27; (length=1)//  4 =&gt; string &#x27;B&#x27; (length=1)// 降序// 分值前三$redis-&gt;zRevRange(&#x27;zSet&#x27;, 0, 2, true);//array (size=3)//  &#x27;B&#x27; =&gt; float 118//  &#x27;A&#x27; =&gt; float 30.5//  &#x27;C&#x27; =&gt; float 20\n\n获取 score 过滤后排序的数据段(zRangeByScore,zRevRangeByScore)\n根据分值过滤之后的列表\n需要提供分值区间\n$redis-&gt;zAdd(&#x27;key&#x27;, 0, &#x27;val0&#x27;);$redis-&gt;zAdd(&#x27;key&#x27;, 2, &#x27;val2&#x27;);$redis-&gt;zAdd(&#x27;key&#x27;, 10, &#x27;val10&#x27;);$redis-&gt;zRangeByScore(&#x27;key&#x27;, 0, 3);                                          // array(&#x27;val0&#x27;, &#x27;val2&#x27;)$redis-&gt;zRangeByScore(&#x27;key&#x27;, 0, 3, array(&#x27;withscores&#x27; =&gt; TRUE);              // array(&#x27;val0&#x27; =&gt; 0, &#x27;val2&#x27; =&gt; 2)$redis-&gt;zRangeByScore(&#x27;key&#x27;, 0, 3, array(&#x27;limit&#x27; =&gt; array(1, 1));                        // array(&#x27;val2&#x27; =&gt; 2)$redis-&gt;zRangeByScore(&#x27;key&#x27;, 0, 3, array(&#x27;limit&#x27; =&gt; array(1, 1));                        // array(&#x27;val2&#x27;)$redis-&gt;zRangeByScore(&#x27;key&#x27;, 0, 3, array(&#x27;withscores&#x27; =&gt; TRUE, &#x27;limit&#x27; =&gt; array(1, 1));  // array(&#x27;val2&#x27; =&gt; 2)\n\n获取元素个数(zCard)\n$redis-&gt;zCard(&#x27;zSet&#x27;);      // \n\n获取区间内的元素个数(zCount)\n$redis-&gt;zAdd(&#x27;key&#x27;, 0, &#x27;val0&#x27;);$redis-&gt;zAdd(&#x27;key&#x27;, 2, &#x27;val2&#x27;);$redis-&gt;zAdd(&#x27;key&#x27;, 10, &#x27;val10&#x27;);// 0 ~ 3 之间$redis-&gt;zCount(&#x27;key&#x27;, 0, 3); // array(&#x27;val0&#x27;, &#x27;val2&#x27;)\n\n获取元素的 score (zScore)\n$redis-&gt;zScore(&#x27;zSet&#x27;, &#x27;A&#x27;)     // 30.5\n\n获取某个元素在集合中的排名(zRank)\n从0开始\n$redis-&gt;zRank(&#x27;zSet&#x27;, &#x27;A&#x27;);    // 3\n\n删除元素(zRem)\n$redis-&gt;zRem(&#x27;zSet&#x27;, &#x27;A&#x27;);\n\n根据排名来删除(zRemRangeByRank)\n//按照升序排序删除第一个和第二个元素$redis-&gt;zRemRangeByRank(&#x27;zSet&#x27;, 0, 1)\n\n根据区间来删除(zRemRangeByScore)\n//删除 score 在[15, 30]之间的元素$redis-&gt;zRemRangeByScore(&#x27;zSet&#x27;, 15, 30);\n\n","categories":["Redis"],"tags":["php","redis"]},{"title":"PHP 中 Redis 常用操作（hash 类型）","url":"/2021/07/124fc284dddc/","content":"Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。\nRedis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。\n当前服务器一般都是将用户登录信息保存到Redis中，这里存储用户登录信息就比较适合用hash表。hash表比string更合适，如果我们选择使用string类型来存储用户的信息的时候，我们每次存储的时候就得先序列化(json_encode()、serialize())成字符串才能存储redis,\n从redis拿到用户信息后又得反序列化(json_decode()、unserialize())成数组或对象，这样开销比较大。如果使用hash的话我们通过key(用户ID)+field(属性标签)就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。\n设置(hSet)\n$redis-&gt;hSet(&#x27;user&#x27;, &#x27;name&#x27;, &#x27;zhaosi&#x27;);$redis-&gt;hSet(&#x27;user&#x27;, &#x27;age&#x27;, 50);$redis-&gt;hSet(&#x27;user&#x27;, &#x27;address&#x27;, &#x27;象牙山&#x27;);\n\n批量设置(hMset)\n$u1 = [    &#x27;id&#x27;=&gt; 1,    &#x27;name&#x27; =&gt; &#x27;liuneng&#x27;,    &#x27;age&#x27;  =&gt; 51,    &#x27;address&#x27; =&gt; &#x27;象牙山&#x27;];$redis-&gt;hMSet(&#x27;user:&#x27;.$u1[&#x27;id&#x27;], $u1);$u2 = [    &#x27;id&#x27; =&gt; 2,    &#x27;name&#x27; =&gt; &#x27;zhaosi&#x27;,    &#x27;age&#x27;  =&gt; 50,    &#x27;address&#x27; =&gt; &#x27;象牙山&#x27;];$redis-&gt;hMSet(&#x27;user:&#x27;.$u2[&#x27;id&#x27;], $u2);\n为什么要给存储的数据加一个前缀呢，比如说上面示例的user前缀？\n因为我们在 redis 一般需要存储很多业务类型的数据，比如用户登录信息、验证码信息，我们都是以用户唯一标识信息(如id,手机号)作为 key，如果不加前缀就会导致多个业务类型的数据就存到一起了，这是不合理也不应该的。所以我们可以以业务名称作为前缀然后配合上用户唯一标识即前缀:唯一标识作为 key，中间是用冒号 : 分隔,这样就可以把数据按照业务类型分开，这也是业界通用的做法， php 中 session 存储默认也是一 PHPREDIS_SESSION 作为前缀，官方都是这么做了，我们还有什么理由不这样做呢。\n获取(hGet)\n$redis-&gt;hGet(&#x27;user&#x27;, &#x27;name&#x27;);      // zhaosi\n\n获取全部元素(hGetAll)\n$redis-&gt;hGetAll(&#x27;user&#x27;);//[//  &#x27;name&#x27; =&gt; &#x27;zhaosi&#x27;,//  &#x27;age&#x27;  =&gt; 50,//  &#x27;address&#x27; =&gt; &#x27;象牙山&#x27;//]\n\n删除某个元素(hDle)\n$redis-&gt;hDel(&#x27;user&#x27;, &#x27;address&#x27;);\n\n判断元素是否存在(hExists)\n$redis-&gt;hExists(&#x27;user&#x27;, &#x27;address&#x27;);     // false\n\n获取长度(hLen)\n$redis-&gt;hSet(&#x27;user&#x27;, &#x27;name&#x27;, &#x27;zhaosi&#x27;);$redis-&gt;hSet(&#x27;user&#x27;, &#x27;age&#x27;, 50);$redis-&gt;hSet(&#x27;user&#x27;, &#x27;address&#x27;, &#x27;象牙山&#x27;);$redis-&gt;hLen(&#x27;user&#x27;);       // 3\n\n","categories":["Redis"],"tags":["php","redis"]},{"title":"PHP 中 Redis 常用操作（基础操作）","url":"/2021/07/6042abf4cf50/","content":"连接 redis 服务器，实例化 redis 对象\n$redis = new Redis();if (!$redis-&gt;connect(&#x27;127.0.0.1&#x27;, 6379)) &#123;    trigger_error(&#x27;Redis连接出错！！！&#x27;, E_USER_ERROR);&#125; else &#123;    echo &quot;连接正常 \\n&quot;;&#125;\n获取所有的key(keys)\n$data = $redis-&gt;keys(&#x27;*&#x27;);var_dump($data);\n判断键对应值的类型(type)\ntype() 方法用户获取一个key对应值的类型,返回值（1:string, 2:set, 3:list, 4:zset, 5:hash 6:未知）\n删除缓存项(del)\n$redis-&gt;del(&#x27;用删除的key&#x27;)\n设置有效期(expire,expireAt)\nexpire() 设置某个时间段后过期\nexpireAt() 在某个时间点(时间戳)过期失效\n$redis-&gt;set(&#x27;user&#x27;, &#x27;user_123456&#x27;);$redis-&gt;expire(&#x27;user&#x27;, 3600);   // 3600 秒后过期$redis-&gt;expireAt(&#x27;user&#x27;, strtotime(&#x27;2020-08-15 00:00:00&#x27;));\n\n获取有效期(ttl)\nttl() 获取某个键的剩余有效期\n$redis-&gt;ttl(&#x27;key&#x27;);  //获取剩余有效期,单位:秒(s)$redis-&gt;pttl(&#x27;key&#x27;); //获取剩余有效期,单位:毫秒(ms)  \n\n检测缓存项是否存在(exists)\nexists() 方法用于检测某个key是否存在\n$redis-&gt;set(&#x27;age&#x27;, 25);if ($redis-&gt;exists(&#x27;age&#x27;)) &#123;    echo &#x27;存在&#x27;;&#125; else &#123;    echo &#x27;不存在&#x27;;&#125;\n\n查看当前数据库key的数量(dbSize)\n$dbSize = $redis-&gt;dbSize();echo $dbSize;\n\n清空当前数据库(flushDB)\n$isFlushed = $redis-&gt;flushDB();var_dump($isFlushed);\n\n清空所有数据库(flushAll)\n会清空所有库的数据，默认是0~15这16个数据库\n$isFlushed = $redis-&gt;flushAll();var_dump($isFlushed);","categories":["Redis"]}]